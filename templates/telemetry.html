{% extends "layout.html" %}
{% block title %} Telemetry {% endblock %}

{% block css %}
{% endblock %}

{% block content %}
	<!-- BEGIN CONTENT-->
	<div id="content">

		<section>

			<div class="section-body">

				<div class="row">
					<div class="col-xs-12">
						<div class="card">
							<div class="card-head">
								<header class="text-primary">Testing heatmap</header>
								<div class="tools">
									<a class="btn btn-icon-toggle btn-collapse"><i class="fa fa-angle-down"></i></a>
								</div>
							</div>
							<div class="card-body heatmap">
								<canvas class="heatmap-canvas" id="telemtry_map" width="840" height="400"></canvas>
							</div>
						</div>
					</div>
				</div>

				<div class="row">
					<div class="col-md-12">
						<div id="timeline"></div>
					</div>
      			</div>

				<div id="results"></div>
				<div id="event_container" class="hide"></div>
			</div>


		</section>
	</div>
	<!-- END CONTENT -->
{% endblock %}


{% block js %}
<!-- BEGIN JAVASCRIPT -->
<script src="/static/telemetry/data.js"></script>
<script src="/static/js/libs/heatmap.min.js"></script>

<script>
var heatmapInstance = h337.create({
  // only container is required, the rest will be defaults
  container: document.querySelector('.heatmap')
});


// now generate some random data
var points = [];
var max = 0;
var width = 840;
var height = 400;
var len=200;

var container = "telemtry_map";
var canvas = document.getElementById(container);
var context = canvas.getContext('2d');

// the radius of the circles that will represent kills
var radius = 6;
var minion_radius = 4;

function drawHeatmap() {
	for (i = 0; i < data.length; i++) {
		item = data[i];

		if (item.type == "KillActor" || item.type == "NPCkillNPC" ) {
			x = transformX(item.payload.Position[0]);
			y = transformY(item.payload.Position[2]);

			if (item.payload.TargetIsHero && item.type == "KillActor") {
				context.beginPath();
				context.arc(x, y, radius, 0, 2 * Math.PI, false);
				context.fillStyle = 'black';
				context.fill();
				context.stroke();

				console.log(x,y);

				var val = Math.floor(Math.random()*100);
				max = Math.max(max, val);
				var point = {
					x: x,
					y: y,
					value: val
				};
			  points.push(point);
			} else {
				context.beginPath();
				context.arc(x, y, minion_radius, 0, 2 * Math.PI, false);
				context.fillStyle = "white";
				context.fill();
				context.stroke();

				var val = Math.floor(Math.random()*100);
				max = Math.max(max, val);
				var point = {
					x: x,
					y: y,
					value: val
				};
			  points.push(point);
			}
		}
	}

	// heatmap data format
	var heatmap_data = {
	  max: max,
	  data: points
	};
	// if you have a set of datapoints always use setData instead of addData
	// for data initialization
	heatmapInstance.setData(heatmap_data);
}

// Transform the telemetry X coordinate to fit the correct map scaling
function transformX(x) {
	return (x - -93) * (width / 185);
}

// Transform the telemetry Y coordinate to fit the correct map scaling
function transformY(y) {
	return (y - -25) * (height / 75);
}

// Add a jquery ui slider and interact with it
$(document).ready(function () {
	var imageObj = new Image();
    imageObj.onload = function() {

		// Add the image to the canvas
		context.drawImage(imageObj, 0, 0, width, height);
		drawHeatmap();
    };
    imageObj.src = '/static/img/vainglory-map.png';

});

</script>
{% endblock %}

