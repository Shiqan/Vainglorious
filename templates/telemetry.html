{% extends "layout.html" %}
{% block title %} Telemetry {% endblock %}

{% block css %}
<style>
canvas {
	width: 100%;
	border:1px solid #eff0f2;
}

#timeline {
	margin:10px;
}

.circle {
  background: #f00;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  display:inline-block;
}

#event_container {
  position: fixed;
  width: 200px;
  height:auto;
   padding: 12px 24px;
  color: #ffffff;
  background-color: #20252b;
  border:1px solid #eff0f2;
  z-index: 10000;
}
</style>
{% endblock %}

{% block content %}
	<!-- BEGIN CONTENT-->
	<div id="content">

		<section>

			<div class="section-body">

				<div class="row">
					<div class="col-xs-12">
						<div class="card">
							<div class="card-head">
								<header class="text-primary">Testing telemetry map</header>
								<div class="tools">
									<a class="btn btn-icon-toggle btn-collapse"><i class="fa fa-angle-down"></i></a>
								</div>
							</div>
							<div class="card-body">
								<canvas id="telemtry_map"></canvas>
							</div>
						</div>
					</div>
				</div>

				<div class="row">
					<div class="col-md-12">
						<div id="timeline"></div>
					</div>
      			</div>

				<div id="results"></div>
				<div id="event_container" class="hide"></div>
			</div>


		</section>
	</div>
	<!-- END CONTENT -->
{% endblock %}


{% block js %}
<!-- BEGIN JAVASCRIPT -->
<script src="/static/telemetry/data.js"></script>

<script>
var container = "telemtry_map";
var canvas = document.getElementById(container);
var context = canvas.getContext('2d');

var canvas_width = canvas.offsetWidth;
var canvas_height = canvas.offsetHeight;

var canvas_offsetLeft = canvas.offsetLeft;
var canvas_offsetTop = canvas.offsetTop;

// the radius of the circles that will represent kills
var radius = 6;
var minion_radius = 4;
var mine_radius = 4;

// keep track of the items that were painted
// this allows our overall list to be smaller incase we need
// to loop through it frequently
var drawn_items = [];

// keep track of the left and right team members/heros
var team = {'left': [], 'right': []};

start_time = new Date(data[0].time).getTime() / 1000;
end_time = new Date(data.slice(-1)[0].time).getTime() / 1000;

// canvas events
canvas.addEventListener('click', detectClick, false);
canvas.addEventListener('mousemove', detectHover, false);

function draw(callback) {
	var imageObj = new Image();
    imageObj.onload = function() {

    	// Add the image to the canvas
    	context.drawImage(imageObj, 0, 0, canvas_width, canvas_height);

    	callback();
    };
    imageObj.src = '/static/img/vainglory-map.png';
}

function drawDataObject(item) {
	//Find hero/hero kills
	if (item.type == "KillActor" || item.type == "NPCkillNPC" ) {
		x = transformX(item.payload.Position[0]);
		y = transformY(item.payload.Position[2]);

		if (item.payload.TargetIsHero && item.type == "KillActor") {

			if (item.payload.KilledTeam == "Left") {
				killed_team_color = "red";
			} else {
				killed_team_color = "blue";
			}

			if (item.payload.Team == "Left") {
				killer_team_color = "red";
			} else {
				killer_team_color = "blue";
			}

			context.beginPath();
	    	context.arc(x, y, radius, 0, 2 * Math.PI, false);
	    	context.fillStyle = killed_team_color;
	    	context.fill();
	    	context.stroke();

	    	// add to our drawn items array:
	    	drawn_items.push(item)
	   	} else if (item.payload.TargetIsHero && item.payload.Source == "Ability__Item__ScoutTrap_Explode") {
			context.beginPath();
	    	context.arc(x, y, radius, 0, 2 * Math.PI, false);
	    	context.fillStyle = "green";
	    	context.fill();
	    	context.stroke();

	   	} else {
			context.beginPath();
	    	context.arc(x, y, minion_radius, 0, 2 * Math.PI, false);
	    	context.fillStyle = "white";
	    	context.fill();
	    	context.stroke();

	    	// add to our drawn items array:
	    	drawn_items.push(item)
		}
	}
}

function buildTeamObject() {
	// ignored kill actors:
	var ignore = ["RangedMinion", "LeadMinion", "Kraken_Captured"];

	for (i = 0; i < data.length; i++) {

		var hero = data[i].payload.Actor.replace(/\*/g, "");

		if (ignore.indexOf(hero) <= -1) {
			// check what team the hero is on
			if (data[i].payload.Team == "Left") {
				if (team.left.indexOf(hero) <= -1) {
					team.left.push(hero);
				}
		   	} else {
		    	if (team.right.indexOf(hero) <= -1) {
					team.right.push(hero);
				}
		   	}
		}
	}
}

// Transform the telemetry X coordinate to fit the correct map scaling
function transformX(x) {
	return (x - -93) * (canvas_width / 185);
}

// Transform the telemetry Y coordinate to fit the correct map scaling
function transformY(y) {
	return (y - -25) * (canvas_height / 75);
}

function detectInsideItem(e) {
	// find where exactly the canvas is on the screen and use the positions as the offset
	var rect = canvas.getBoundingClientRect();
	mx = e.clientX - rect.left;
    my = e.clientY - rect.top;

    for (i = 0; i < drawn_items.length; i++) {

    	cx = transformX(drawn_items[i].payload.Position[0]);
		cy = transformY(drawn_items[i].payload.Position[2]);

		// determine what radius to use
		if (drawn_items[i].payload.TargetIsHero) {
			calc_radius = radius;
		} else {
			calc_radius = minion_radius;
		}

		// distance formula
		var distance = Math.sqrt(Math.pow((mx - cx), 2) + Math.pow((my - cy), 2));
		if (distance <= radius) {
			return true;
		}
	}

	return false;
}

// detect if user clicked on a kill event in the canvas
function detectClick(e) {

	if (detectInsideItem(e)) {
		drawOverlay(drawn_items[i], true, e.clientX, e.clientY);
	} else {
		drawOverlay(false, false, false, false);
	}
}

function detectHover(e) {
	if (detectInsideItem(e)) {
		canvas.style.cursor = "pointer";
	} else {
		canvas.style.cursor = "default";
	}
}

// show/hide the overlay
function drawOverlay(selectedItem, display, x, y) {
	var overlay = $("#event_container");

	if (display) {
		overlay.removeClass('hide');
		overlay.css({'left': x, 'top': y});

		var content_string = selectedItem.payload.Actor + " killed " + selectedItem.payload.Killed;
		var cleaned_content_string = content_string.replace(/\*/g, "");
		overlay.html(cleaned_content_string);
	} else 	{
		overlay.addClass('hide');
	}
}

function findHeroItems(hero) {
	// reset the drawn items
	drawn_items = [];
	draw(function () {
		for (i = 0; i < data.length; i++) {

			var item_actor_hero = data[i].payload.Actor.replace(/\*/g, "");
			var item_killed_hero = '';
			if (typeof data[i].payload.Killed != "undefined") {
			   item_killed_hero = data[i].payload.Killed.replace(/\*/g, "");
			}

			if (hero == item_killed_hero || hero == item_actor_hero) {
				drawDataObject(data[i]);
			}
		}
	});
}

function drawMap() {
	console.log("DrawMap");

	// reset the drawn items:
	drawn_items = [];

	// resize the canvas:
	canvas_width = canvas.offsetWidth;
	canvas_height = canvas.offsetHeight;

	context.canvas.width  = canvas_width;
	context.canvas.height = canvas_height;

	draw(function () {

		// loop through every item
		for (i = 0; i < data.length; i++) {
		    drawDataObject(data[i]);
		}
	});
}
// Initialize the page load. Draw the image then draw the telemetry items
setTimeout(drawMap(), 10);


// Add a jquery ui slider and interact with it
$(document).ready(function () {

	buildTeamObject();

	/*
	$( "#timeline" ).slider({
		range: "max",
		min: start_time,
		max: end_time,
		value: start_time,
		slide: function( event, ui ) {

			// reset the drawn items:
			drawn_items = [];

			// calculate the time difference
			var diffMs = (ui.value - start_time);
			var diffMins = Math.floor(diffMs/60);

			draw(function () {
				// loop through the data set to see if it the items exist in the time frame
				$.each(data, function (key, item) {
					item_time = new Date(item.time).getTime() / 1000;

					if (item_time <= ui.value) {
						drawDataObject(item);
					}
				})
			})
		}
	});
	*/

	// Show the hero's kills/deaths
	$(".toggleItems").click(function() {
		$(".toggleItems").removeClass('active');
		$(this).addClass('active');
		var hero = $(this).attr("hero");
		findHeroItems(hero);
	});
	drawn_items = [];


});

$( window ).resize(function() {
  window.addEventListener('resize', drawMap());
});

</script>
{% endblock %}

